# 실행컨텍스트

자바스크립트는 어떤 실행 컨텍스트가 활성화 되는 시점에 선언된 변수를 위로 끌어올리고 (hoisting),  
외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행한다. 이로 인해 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생.

## <span style="color: orange">스택 & 큐</span>

**스택(Stack)**: FILO 출입구가 하나! 비어있는 스택에 순서대로 1,2,3,4 로 저장하면 꺼낼 때는 4,3,2,1 로 꺼내야 한다.  
**큐(Queue)**: FIFO 양쪽이 모두 열려있는 파이프! 종류에 따라 양쪽 모두 입력과 출력이 가능한 큐도 있지만, 보통 한쪽은 입력만 다른 한쪽은 출력만을 담당

<img src="https://media.vlpt.us/images/jabggujb9/post/5ffb24dc-c8c2-4aac-b579-627574a12d7f/image.png" />

<br>
<br>

## <span style="color: orange">1. 실행 컨텍스트란?</span>

실행할 때 필요한 환경 정보들을 모아놓은 객체  
동일한 환경에 있는 코드들을 실행할 때 필요한 환경정보들을 모아 컨텍스트를 구성하고,  
이를 콜 스택에 쌓아올렸다가, 가장 위에 쌀여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장한다.  
여기서 _"동일한 환경"_ , 즉 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역공간, eval() 함수, 함수 등이 있다.  
우리가 흔히 실행 컨텍스트를 구성하는 방법은 **함수를 실행** 하는 것 뿐. (ES6 에서는 _"블록{}"_ 에 의해서도 새로운 실행컨텍스트가 생성된다.)

[에제1번] 실행컨텍스트와 콜 스택.

```js
// ------------------------------------- (1)

/* (1) 자바스크립트 코드 실행하는 순간.
 * 전역 컨텍스트가 콜 스택에 담긴다.
 * 전역 컨텍스트: 일반적인 실행 컨텍스트와 특별히 다를 것이 없음.
 * 최상단의 공간은 코드 내부에서 별도의 실행 명령이 없어도 브라우저에서 자동으로 실행하므로,
 * 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화된다.
 */

var a = 1;

function outer() {
  function inner() {
    console.log(a); // undefined
    var a = 3;
  }

  inner(); // -----------------(2)
  /* inner 함수가 다시 콜스택의 최상단에 들어가게 된다.
   * outer 멈추고 inner 함수 내부의 코드 순차적으로 실행.
   */
  console.log(a);
}

outer(); // ------------------(3)
/* outer함수를 호출하면 outer 에 대한 환경 정보를 수집해 실행컨텍스트를 생성 후 콜스택에 담는다.
 * 콜스택의 맨 위에 outer 실행컨텍스트가 놓인 상태 전역 컨텍스트 멈추고 outer 부터 코드 실행.
 */
console.log(a);
```

> 실행 컨택스트가 콜 스택의 맨 위에 쌓이는 순간이 현재 실행할 코드에 관여하게 되는 시점. => 런타임 !!  
> 어떤 실행컨텍스트가 활성화 될 때, 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해 실행 컨텍스트 객체에 저장.  
> 자바스크립트 엔진이 활용할 목적으로 생성할 뿐 개발자가 코드를 통해서 확인할 수는 없다.  
> 🧐 **"This"** Binding 의 시점 !!!

| <p style="font-size: 18px">실행컨텍스트 객체에 담기는 것 <p> |                                                                                                                                          |     |
| ------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------- | --- |
| **VariableEnvironment**                                      | 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보.<br/> 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경 사항은 반영되지 않는다. |
| **LexicalEnvironment**                                       | 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨.                                                                     |
| **💡ThisBinding**                                            | 식별자가 바라봐야하는 대상.                                                                                                              |

<br>
<br>

## <span style="color: orange">2. Variable Environment</span>

Variable Environment 에 담기는 내용은 Lexical Environment 와 같지만 최초 실행 시의 스냅샷을 유지.  
실행 컨텍스트를 생성할 때, Variable Environment 를 만들에 정보를 담고, 이를 그대로 복사한 Lexical Environment를 사용.  
EnvironmentRecord , Outer-EnvironmentReference로 구성.  
초기화 과정 중에는 사실상 완전히 동일하고 이후 코드 진행에 따라 달라진다.

## <span style="color: orange">3. Lexical Environment</span>

LixicalEnvrironment (어휘적 환경)  
EnvironmentRecord , Outer-EnvironmentReference로 구성.

현재 컨텍스트의 내부에 a,b,c 와 같은 식별자가 있다면, 그 외부 정보는 D를 참조하도록 구성되어있다.  
컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것.  
=> 식별자들이 참조하는 값.

### 3 - 1. EnvironmentRecord 와 호이스팅.

environmentRecord 에는 현재 컨텍스트와 관련된 코드의 **식별자** 정보들이 **순서대로** 저장.  
ex) 식별자 : 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체, var로 선언된 변수의 식별자 등.

참고: 전역실행컨텍스트는 변수 객체를 생성하지 않고 자바스크립트를 구동하는 환경이 별도로 제공하는 객체.  
즉, 전역객체 (global object) 를 활용한다. 브라우저 = window / Node.js = global 객체.  
이들은 자바스크립트의 내장 객체가 아니라 호스트 객체로 분류됨.

변수 정보를 수집하는 과정을 모두 마쳤다해도, 실행컨텍스트가 관여할 코드들은 실행되기 전 상태.  
그렇지만 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명을 모두 알 수 있는 것.  
엔진이 실제 동작하는 방식 대신에, 자바스크립트의 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다. => 호이스팅.  
자바스크립트 엔진이 실제로 끌어올리는 것은 아니지만, 끌어올린 것으로 간주.
