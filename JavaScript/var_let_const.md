# var - let - const

> " var - let - const " 들어가기 전, 모든 변수는 `스코프`(scope, 유효범위)를 가진다.  
> 변수의 관점에서 스코프를 구분해보면 전역변수(global variable), 지역변수(local variable)로 나눠지는데  
> 이는 변수가 어디에서 "선언"되었는지에 따라 결정된다.

전역 스코프를 가지는 전역변수는 코드 내 어디서든지 참조할 수 있고 접근 가능하다.  
지역에서 선언된 지역 변수는 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다.

대부분의 프로그래밍 언어는 블록 레벨 스코프를 따르지만 **자바스크립트는 함수 레벨 스코프**를 따른다.

- **함수레벨스코프** : 함수 내에 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다.  
  함수 내부에서 선언한 변수 - 지역변수  
  함수 외부에서 선언한 변수 - 전역변수

- **블록레벨스코프** : 모든 코드블록 `"{ }"`( `함수`, `if문`, `for문`, `while문`, `trt/catch문` 등 )내에서 선언된 변수는  
  코드블록 내에서만 유효하고, 코드 블록 외부에서는 참조할 수 없다.  
  코드블록 내부에서 선언한 변수 -> `지역변수`  
  코드블록 외부에서 선언한 변수 -> `전역변수`

## var 키워드로 선언한 변수의 문제점

1. **변수 중복 선언 허용** - 변수의 중복 선언이 가능하다. 즉, 먼저 선언된 변수 값이 변경되는 부작용 발생.

```jsx
var x = 1;
var x = 100;
console.log(x); // 100;

// let의 경우 에러발생.
let x = 1;
let x = 100; // Uncaught SyntaxError: Identifier 'x' has already been declared
```

2. **함수 레벨 스코프** - 함수의 코드 블록만을 지역 스코프로 인정한다.  
   따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.

- `for`, `while`, `if` 문 등 내에서 `var` 를 사용하면 전역변수!

```jsx
// var 사용.
var x = 1;

// if {} 코드블록 내에 선언되었지만 함수가 아니기 때문에 전역 스코프를 가진다.
if (true) {
  var x = 10; // 전역변수 x. -> 변수가 중복 선언된다.
  console.log(x);
}
console.log(x); // 10

// let 사용.
let x = 1;

if (true) {
  let x = 10;
  console.log(x); // 10
}
console.log(x); // 1
```

3. **변수 호이스팅** - 변수 선언 전에 참조할 수 있다.  
   변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌러 올려진 것처럼 동작한다.  
   변수 선언문 이전에 참조할 수 있다.

```jsx
// 1. 변수 선언: 이 시점에서 변수 호이스팅에 의해 이미 foo 변수가 선언되었음.
// 2. 변수 초기화: 변수 foo 는 undefined 로 초기화
console.log(foo);

// 3.변수 할당.
foo = 123;

console.log(foo);

// 변수 선언은 *런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행된다.
var foo;
```

_런타임(run time): 프로그래밍 언어가 구동되는 환경._

**_*var 키워드의 단점을 보완하기 위해 ES6에서는 새로운 변수 선언 키워드인 let과 const를 도입했다.*_**

## let 키워드

1. 변수 **중복 선언** **금지**

2. **블록 레벨 스코프** - 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

```jsx
// 전역변수 i
let i = 100;

function foo() {
  // 함수 내 지역변수 i
  let i = 10;

  for (let i = 1; i < 3; i++) {
    // 블록 내 지역변수 i
    console.log('블록레벨스코프' + i);
  }
  console.log('함수레벨스코프' + i);
}
foo();
console.log('전역스코프' + i);

// 블록레벨스코프1
// 블록레벨스코프2
// 함수레벨스코프10
// 전역스코프100
```

3. 변수 호이스팅  
   `var` 키워드로 선언한 변수와 달리 `let` 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작함.  
   → `let` 키워드로 선언한 변수는 "선언단계"와 "초기화단계"가 분리되어 진행.  
   → 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 **참조 에러** 발생.  
   → `let` 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문) 까지 변수를 참조할 수 없고

이처럼 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대(TDZ :Temporal Dead Zone)** 라고 부른다.

```jsx
// 런타임 이전에 선언 단계가 실행된다. 선언 및 호이스팅 된 상태, 초기화는 안 된 상태.
// 초기화 이전의 일시적 사각지대에서는 변수를 참조할 수 없다.(TDZ)
console.log(foo); // Uncaught ReferenceError: foo is not defined at <anonymous>:1:13

let foo; // 초기화 단계 실행.
console.log(foo); // undefined

foo = 1; // 할당.
console.log(foo); // 1
```

4. 전역 객체와 let  
   `let` 으로 선언한 변수는 전역 객체의 프로퍼티가 아니다.  
   위의 코드에서 `window.foo` 와 같이 접근할 수가 없다.

## const 키워드

`const` 는 상수를 선언하기 위해서 사용된다.(반드시 상수만을 위한 것은 아님.)  
`let` 과 비슷한 특징을 가짐.

1. 선언과 초기화 - **선언과 초기화를 동시에** 해야한다. 안그러면 syntax 에러.

2. 재할당 금지.

3. 상수 - const 변수에 할당한 값이 원시값(primitive type)인 경우, 원시값의 특성대로 변경이 불가능하다.  
   즉, const 키워드로 선언된 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값이고,  
   const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.  
   이런 경우 대문자와 `snake_case`를 사용해 변수명을 구분해준다. ex) `const TAX_RATE = 0.1;`

4. 객체 - 만약 `const` 키워드로 선언된 변수에 객체를 할당한 경우에는 값을 변경할 수 있다.  
   → 객체의 `value` 는 변경 가능하다. 재할당을 금지할 뿐 불변을 의미하는 것은 아님.

```jsx
const person = {
  name: 'haesoo',
};
console.log(person.name); // "haesoo"

person.name = 'Jeong';
console.log(person); // {name: "Jeong"}
```

## 요약

- 모던한 개발을 위해 `var` 사용 지양.

- 재할당이 필요한 경우에 한 해 `let` 사용. 변수의 `스코프`는 최대한 좁게.

- 변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요없는 상수) 원시값과 객체에는 `const` 키워드를 사용한다.  
  `const` 는 재할당이 금지되기때문에 `let`,`var` 보다 안전하다.

<br>
참고 - 모던 자바스크립트 DEEP DIVE
